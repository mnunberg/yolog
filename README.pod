=head1 YOLOG

Yolog - Free Contextual Logging For All!

=head1 DESCRIPTION

C<Yolog> is a small library (but not only a library) whose purpose is to
provide a customizable and easy way for projects to log screen information.

Basically 'print-debugging' on steroids, Yolog provides contextual information
with each message.

The following information can be obtained with each message

=over

=item Thread Identification

=item Process Identification

=item Source File/Line/Function

=item User Defined Subsystem

=item Color-coded Severity Display

=back

Yolog can be used as a DSO, or it can be embedded into your project with the
C<genyolog.pl> script.

Yolog can employ variadic macros as present in C99, or fallback to C89 mode
with some clever tricks.

Yolog should be simple to use in your code:

DSO Version:

    #include <yolog.h>

    static void myfunc(void)
    {
        yolog_debug("This won't print because severity is too low");
        yolog_warn("But this will show a warning");
    }

    int main(void) {
        yolog_init_defaults(
            NULL, /* no specialized context */
            0, /* no contexts to count */,
            YOLOG_WARN, /* minimum severity level to log */
            "DEBUG", /* environment variable to control severity filtering */
            "DEBUG_COLOR" /* environment variable to control color output */
        );
        myfunc();
        return 0;
    }

Embedded Version:

    #include "yolog_out/myapp_yolog.h"
    static void myfunc(void)
    {
        myapp_debug("This won't print");
        myapp_warn("This will print a warning");
    }

    int main(void)
    {
        myapp_yolog_init();
        myfunc();
        return 0;
    }

The embedded Yolog generated source will configure logging functions
which will have a namespace of your choosing prefixed to them. This
avoids name clashes and makes it interoperable with any other logging
module/wrapper you wish to use.


=head2 CONFIGURING

Yolog is designed to be embedded easily. The initial cost is in learning the
script and possible having Perl installed (it's already on every unix out there)
to generate the source code.

The code generated by the script can be either intended for wrapping the Yolog
dynamic library (C<libyolog>) in which case the actual logging code is not
embedded into your project, but the customized debugging and initialization
wrappers are still provided. Yolog can also be static in which it will create
a copy of the source code, mangling the symbols in such a way to avoid
possible conflicts with any other logging library that may be in use.

The embedding of Yolog requires knowing the location to the Yolog source
itself.

The file C<conf/sample.cnf> shows a simple configuration in conjunction with a
simple 'project' (located in the C<demo> directory). This project has Makefile
targets for both static and dynamic Yolog using the same codebase.

A simple configuration should look like this

    # Your app's 'namespace'. This will be prefixed to everything
    symbol_prefix myproj

    # By default, debug macros have the same prefix as the namespace. This
    # option will provide a customized prefix. Instead of myproj_debug, we can do
    macro_prefix log
    # and do log_debug

    # Environment variables to manipulate the debugging level and options
    env_color MYAPP_DEBUG_COLOR
    env_debug MYAPP_DEBUG_LEVEL

    # Now, sometimes an app wants more than a single logging source. This helps
    # filter out messages based on subsystem/component rather than simple severity.
    subsys io
    subsys config
    subsys main

Now, assuming we've saved this file to C<myapp.conf> we will do the following
to generate the Yolog files

For a dynamic Yolog, do

    $ ./srcutil/genyolog.pl -c myapp.conf -o myapp_yolog

For a static Yolog:

    $ ./srcutil/genyolog.pl -c myapp.conf --static -o myapp_yolog -y /usr/src/yolog

In either case, a new directory C<myapp_yolog> will be created, and there will
be two files, C<myapp_yolog.c> and C<myapp_yolog.h>. The source file should be
linked in with your application, and the header file included.

Assuming that the C<myapp_yolog> directory is in your compiler's search path,
the following would be done in order to use the logging libraries

    #include <myapp_yolog/myapp_yolog.h>
    /* other stuff */

    int main(void) {
        myapp_yolog_init();

        log_debug("This is a debug message");
        log_io_error("IO Error!");
        log_config_warn("Configuration Option has no effect!");
    }

Simples!

If you wanted to add some color

    $ export MYAPP_DEBUG_COLOR = 1
    $ ./myapp

Or if you wanted to silence all debug output

    $ export MYAPP_DEBUG_LEVEL = 1000
    $ ./myapp

Which sets the threshhold for the minimum allowed level.

=head2 FORMAT STRINGS

Yolog can be configured with format strings. To see the various
options, look in the header

=head2 PORTABILITY

I've managed to compile libyolog on GCC for Linux, Windows, Solaris.

The sample application has POSIX-isms (like pthreads) and won't work
on Windows (though if someone cares to point me on how to accomplish
this, I'm open..).

Additionally, goodies like thread display, implicit locked context, and
locking the output stream so two threads don't write to it simultaneously
using C<flockfile> are not available on Win32.

=head1 AUTHOR AND COPYRIGHT

Copyright 2010-2012 M. Nunberg

See LICENSE for licensing information
